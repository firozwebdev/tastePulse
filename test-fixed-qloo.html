<!DOCTYPE html>
<html>
<head>
    <title>üéâ Test Fixed Qloo Integration</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; }
        .test-section { 
            margin: 20px 0; 
            padding: 20px; 
            border: 2px solid #ddd; 
            border-radius: 8px; 
            background: white;
        }
        .success { border-color: #28a745; background: #d4edda; }
        .error { border-color: #dc3545; background: #f8d7da; }
        .loading { border-color: #17a2b8; background: #d1ecf1; }
        button { 
            padding: 12px 24px; 
            margin: 8px; 
            cursor: pointer; 
            border: none;
            border-radius: 4px;
            font-weight: bold;
            background: #28a745;
            color: white;
        }
        pre { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 4px; 
            overflow-x: auto; 
            font-size: 12px;
        }
        h1 { color: #333; text-align: center; }
        h2 { color: #28a745; }
        .status-real { background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .status-mock { background: #dc3545; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .recommendation { 
            background: #f8f9fa; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 8px; 
            border-left: 4px solid #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéâ Test Fixed Qloo Integration</h1>
        <p style="text-align: center; color: #666;">
            Testing the fixed integration using the working /search endpoint
        </p>

        <div class="test-section">
            <h2>üß™ Test Complete Flow</h2>
            <button onclick="testCompleteFlow()">Test Full Gemini ‚Üí Fixed Qloo Flow</button>
            <div id="complete-result"></div>
        </div>

        <div class="test-section">
            <h2>üéØ Test Specific Categories</h2>
            <button onclick="testCategory('music', 'jazz')">Test Music</button>
            <button onclick="testCategory('food', 'pizza')">Test Food</button>
            <button onclick="testCategory('book', 'fiction')">Test Books</button>
            <button onclick="testCategory('travel', 'tokyo')">Test Travel</button>
            <div id="category-result"></div>
        </div>

        <div class="test-section">
            <h2>üìä Results Analysis</h2>
            <div id="analysis-result"></div>
        </div>
    </div>

    <script>
        async function testCompleteFlow() {
            const resultDiv = document.getElementById('complete-result');
            resultDiv.className = 'loading';
            resultDiv.innerHTML = '<p>üîÑ Testing complete flow with fixed Qloo integration...</p>';

            try {
                // Step 1: Parse with Gemini
                const parseResponse = await fetch('/.netlify/functions/parse-taste', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: "I love jazz music, Italian pizza, contemporary fiction books, and traveling to Japan"
                    })
                });

                if (!parseResponse.ok) {
                    throw new Error(`Parse API error: ${parseResponse.status}`);
                }

                const parsedData = await parseResponse.json();

                // Step 2: Get recommendations with fixed Qloo
                const recsResponse = await fetch('/.netlify/functions/get-recommendations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parsedTaste: parsedData })
                });

                if (!recsResponse.ok) {
                    throw new Error(`Recommendations API error: ${recsResponse.status}`);
                }

                const recommendations = await recsResponse.json();

                // Analyze results
                let resultHTML = '<h3>üéâ Complete Flow Results</h3>';
                
                // Show data source status
                if (recommendations.metadata && recommendations.metadata.usedMockData) {
                    const realCategories = Object.entries(recommendations.metadata.usedMockData)
                        .filter(([cat, isMock]) => !isMock)
                        .map(([cat]) => cat);
                    const mockCategories = Object.entries(recommendations.metadata.usedMockData)
                        .filter(([cat, isMock]) => isMock)
                        .map(([cat]) => cat);

                    if (realCategories.length > 0) {
                        resultHTML += '<p><span class="status-real">REAL QLOO DATA</span> ' + realCategories.join(', ') + '</p>';
                    }
                    if (mockCategories.length > 0) {
                        resultHTML += '<p><span class="status-mock">MOCK DATA</span> ' + mockCategories.join(', ') + '</p>';
                    }
                }

                // Show recommendations
                if (recommendations.recommendations) {
                    Object.entries(recommendations.recommendations).forEach(([category, items]) => {
                        resultHTML += `<h4>${category.charAt(0).toUpperCase() + category.slice(1)} (${items.length} items)</h4>`;
                        
                        items.slice(0, 2).forEach(item => {
                            resultHTML += `<div class="recommendation">`;
                            resultHTML += `<strong>${item.name}</strong> (${item.match}% match)<br>`;
                            resultHTML += `<em>${item.description}</em><br>`;
                            resultHTML += `<small>Source: ${item.source || 'unknown'} | Category: ${item.category}</small>`;
                            resultHTML += `</div>`;
                        });
                    });
                }

                resultHTML += '<h4>Raw Response:</h4>';
                resultHTML += '<pre>' + JSON.stringify(recommendations, null, 2) + '</pre>';

                resultDiv.className = 'success';
                resultDiv.innerHTML = resultHTML;

                // Update analysis
                updateAnalysis(recommendations);

            } catch (error) {
                resultDiv.className = 'error';
                resultDiv.innerHTML = `<h3>‚ùå Complete Flow Failed</h3><p>${error.message}</p>`;
            }
        }

        async function testCategory(category, query) {
            const resultDiv = document.getElementById('category-result');
            resultDiv.className = 'loading';
            resultDiv.innerHTML = `<p>üîÑ Testing ${category} category...</p>`;

            try {
                const testTaste = {};
                testTaste[category] = query;

                const response = await fetch('/.netlify/functions/get-recommendations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parsedTaste: testTaste })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();

                let resultHTML = `<h3>${category.charAt(0).toUpperCase() + category.slice(1)} Test Results</h3>`;
                
                if (data.metadata && data.metadata.usedMockData) {
                    const isMock = data.metadata.usedMockData[category];
                    if (isMock === false) {
                        resultHTML += '<p><span class="status-real">REAL QLOO DATA</span></p>';
                    } else {
                        resultHTML += '<p><span class="status-mock">MOCK DATA</span></p>';
                    }
                }

                if (data.recommendations && data.recommendations[category]) {
                    const items = data.recommendations[category];
                    resultHTML += `<p>Found ${items.length} recommendations:</p>`;
                    
                    items.slice(0, 3).forEach(item => {
                        resultHTML += `<div class="recommendation">`;
                        resultHTML += `<strong>${item.name}</strong> (${item.match}% match)<br>`;
                        resultHTML += `<em>${item.description}</em><br>`;
                        resultHTML += `<small>Source: ${item.source} | Category: ${item.category}</small>`;
                        resultHTML += `</div>`;
                    });
                }

                resultDiv.className = 'success';
                resultDiv.innerHTML = resultHTML;

            } catch (error) {
                resultDiv.className = 'error';
                resultDiv.innerHTML = `<h3>‚ùå ${category} test failed</h3><p>${error.message}</p>`;
            }
        }

        function updateAnalysis(data) {
            const analysisDiv = document.getElementById('analysis-result');
            
            let analysisHTML = '<h3>üìä Integration Analysis</h3>';
            
            if (data.metadata) {
                analysisHTML += '<h4>Metadata:</h4>';
                analysisHTML += '<ul>';
                analysisHTML += `<li><strong>API Endpoint:</strong> ${data.metadata.apiEndpoint || 'unknown'}</li>`;
                analysisHTML += `<li><strong>Timestamp:</strong> ${data.metadata.timestamp}</li>`;
                if (data.metadata.message) {
                    analysisHTML += `<li><strong>Message:</strong> ${data.metadata.message}</li>`;
                }
                analysisHTML += '</ul>';
            }

            if (data.recommendations) {
                const totalCategories = Object.keys(data.recommendations).length;
                const totalRecommendations = Object.values(data.recommendations)
                    .reduce((sum, items) => sum + items.length, 0);
                
                analysisHTML += '<h4>Summary:</h4>';
                analysisHTML += '<ul>';
                analysisHTML += `<li><strong>Categories processed:</strong> ${totalCategories}</li>`;
                analysisHTML += `<li><strong>Total recommendations:</strong> ${totalRecommendations}</li>`;
                analysisHTML += '</ul>';
            }

            analysisDiv.innerHTML = analysisHTML;
        }

        // Auto-run test on page load
        window.onload = function() {
            setTimeout(() => {
                testCompleteFlow();
            }, 1000);
        };
    </script>
</body>
</html>
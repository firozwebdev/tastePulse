<!DOCTYPE html>
<html>
<head>
    <title>üîç Verify Real Qloo Data</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; }
        .test-section { 
            margin: 20px 0; 
            padding: 20px; 
            border: 2px solid #ddd; 
            border-radius: 8px; 
            background: white;
        }
        .success { border-color: #28a745; background: #d4edda; }
        .error { border-color: #dc3545; background: #f8d7da; }
        .warning { border-color: #ffc107; background: #fff3cd; }
        .loading { border-color: #17a2b8; background: #d1ecf1; }
        button { 
            padding: 12px 24px; 
            margin: 8px; 
            cursor: pointer; 
            border: none;
            border-radius: 4px;
            font-weight: bold;
            background: #007bff;
            color: white;
        }
        pre { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 4px; 
            overflow-x: auto; 
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        h1 { color: #333; text-align: center; }
        h2 { color: #007bff; }
        .real-data { background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .mock-data { background: #dc3545; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .indicator { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 4px; 
            font-weight: bold;
        }
        .real-indicator { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .mock-indicator { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Verify Real Qloo Data</h1>
        <p style="text-align: center; color: #666;">
            Let's verify if we're getting real Qloo data or mock data
        </p>

        <div class="test-section">
            <h2>üéØ Test Real vs Mock Data</h2>
            <button onclick="testRealVsMock()">Test Real vs Mock Data Detection</button>
            <div id="real-mock-result"></div>
        </div>

        <div class="test-section">
            <h2>üîç Analyze Qloo Response Patterns</h2>
            <button onclick="analyzeQlooPatterns()">Analyze Response Patterns</button>
            <div id="pattern-result"></div>
        </div>

        <div class="test-section">
            <h2>üß™ Test Different Queries</h2>
            <button onclick="testQuery('jazz')">Test: Jazz</button>
            <button onclick="testQuery('pizza')">Test: Pizza</button>
            <button onclick="testQuery('tokyo')">Test: Tokyo</button>
            <button onclick="testQuery('science fiction')">Test: Sci-Fi</button>
            <div id="query-result"></div>
        </div>

        <div class="test-section">
            <h2>üìä Data Quality Analysis</h2>
            <div id="quality-result"></div>
        </div>
    </div>

    <script>
        async function testRealVsMock() {
            const resultDiv = document.getElementById('real-mock-result');
            resultDiv.className = 'loading';
            resultDiv.innerHTML = '<p>üîÑ Testing real vs mock data...</p>';

            try {
                // Test with a specific input that should give us clear results
                const testInput = "I love jazz music and Italian pizza";
                
                // Step 1: Parse the input
                const parseResponse = await fetch('/.netlify/functions/parse-taste-simple', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input: testInput })
                });

                const parsedData = await parseResponse.json();
                console.log('Parsed data:', parsedData);

                // Step 2: Get recommendations
                const recsResponse = await fetch('/.netlify/functions/get-recommendations-fixed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parsedTaste: parsedData })
                });

                const recommendations = await recsResponse.json();
                console.log('Recommendations:', recommendations);

                // Analyze the results
                let resultHTML = '<h3>üîç Real vs Mock Data Analysis</h3>';
                
                // Check metadata
                if (recommendations.metadata) {
                    resultHTML += '<h4>Metadata Analysis:</h4>';
                    resultHTML += '<div class="indicator ' + (recommendations.metadata.usedMockData ? 'mock-indicator' : 'real-indicator') + '">';
                    
                    if (recommendations.metadata.usedMockData) {
                        const mockCategories = Object.entries(recommendations.metadata.usedMockData)
                            .filter(([cat, isMock]) => isMock)
                            .map(([cat]) => cat);
                        const realCategories = Object.entries(recommendations.metadata.usedMockData)
                            .filter(([cat, isMock]) => !isMock)
                            .map(([cat]) => cat);

                        if (realCategories.length > 0) {
                            resultHTML += '<span class="real-data">REAL QLOO DATA</span> for: ' + realCategories.join(', ') + '<br>';
                        }
                        if (mockCategories.length > 0) {
                            resultHTML += '<span class="mock-data">MOCK DATA</span> for: ' + mockCategories.join(', ') + '<br>';
                        }
                    } else {
                        resultHTML += '<span class="real-data">ALL REAL QLOO DATA</span><br>';
                    }
                    
                    resultHTML += '<strong>API Endpoint:</strong> ' + (recommendations.metadata.apiEndpoint || 'unknown') + '<br>';
                    resultHTML += '<strong>Message:</strong> ' + (recommendations.metadata.message || 'none') + '<br>';
                    resultHTML += '</div>';
                }

                // Analyze recommendation quality
                if (recommendations.recommendations) {
                    resultHTML += '<h4>Recommendation Quality Analysis:</h4>';
                    
                    Object.entries(recommendations.recommendations).forEach(([category, items]) => {
                        if (items && items.length > 0) {
                            resultHTML += `<h5>${category.charAt(0).toUpperCase() + category.slice(1)} (${items.length} items):</h5>`;
                            
                            // Check for signs of real vs mock data
                            const firstItem = items[0];
                            const indicators = [];
                            
                            // Check for generic descriptions
                            if (firstItem.description && firstItem.description.includes('Great ' + category + ' recommendation')) {
                                indicators.push('‚ùå Generic description pattern');
                            } else if (firstItem.description && firstItem.description.length > 50) {
                                indicators.push('‚úÖ Detailed description');
                            }
                            
                            // Check for specific names vs generic names
                            if (firstItem.name && !firstItem.name.includes('Mock') && !firstItem.name.includes('Sample')) {
                                indicators.push('‚úÖ Specific name: ' + firstItem.name);
                            } else {
                                indicators.push('‚ùå Generic/Mock name: ' + firstItem.name);
                            }
                            
                            // Check for Qloo entity IDs
                            if (firstItem.id && firstItem.id.includes('qloo_')) {
                                indicators.push('‚úÖ Qloo entity ID format');
                            }
                            
                            // Check source
                            if (firstItem.source === 'qloo') {
                                indicators.push('‚úÖ Source marked as Qloo');
                            } else if (firstItem.source === 'mock') {
                                indicators.push('‚ùå Source marked as Mock');
                            }
                            
                            resultHTML += '<ul>';
                            indicators.forEach(indicator => {
                                resultHTML += '<li>' + indicator + '</li>';
                            });
                            resultHTML += '</ul>';
                            
                            // Show first item as example
                            resultHTML += '<div style="background: #f8f9fa; padding: 10px; margin: 5px 0; border-radius: 4px;">';
                            resultHTML += '<strong>Example:</strong> ' + firstItem.name + '<br>';
                            resultHTML += '<em>' + firstItem.description + '</em><br>';
                            resultHTML += '<small>Match: ' + firstItem.match + '% | Source: ' + firstItem.source + '</small>';
                            resultHTML += '</div>';
                        }
                    });
                }

                resultHTML += '<h4>Raw Response:</h4>';
                resultHTML += '<pre>' + JSON.stringify(recommendations, null, 2) + '</pre>';

                resultDiv.className = 'success';
                resultDiv.innerHTML = resultHTML;

            } catch (error) {
                resultDiv.className = 'error';
                resultDiv.innerHTML = `<h3>‚ùå Test Failed</h3><p>${error.message}</p>`;
            }
        }

        async function analyzeQlooPatterns() {
            const resultDiv = document.getElementById('pattern-result');
            resultDiv.className = 'loading';
            resultDiv.innerHTML = '<p>üîÑ Analyzing Qloo response patterns...</p>';

            try {
                const testQueries = ['jazz', 'pizza', 'tokyo', 'science fiction'];
                const allResults = [];

                for (const query of testQueries) {
                    try {
                        const response = await fetch('/.netlify/functions/get-recommendations-fixed', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                parsedTaste: { 
                                    music: query === 'jazz' ? { genres: [query], artists: [] } : undefined,
                                    food: query === 'pizza' ? { cuisines: [query], dishes: [] } : undefined,
                                    travel: query === 'tokyo' ? { destinations: [query], activities: [] } : undefined,
                                    books: query === 'science fiction' ? { genres: [query], authors: [] } : undefined
                                }
                            })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            allResults.push({ query, data });
                        }
                    } catch (e) {
                        console.warn(`Failed to test ${query}:`, e);
                    }
                }

                let resultHTML = '<h3>üìä Qloo Pattern Analysis</h3>';

                if (allResults.length > 0) {
                    resultHTML += '<h4>Pattern Detection:</h4>';
                    
                    // Analyze patterns across all results
                    const patterns = {
                        genericDescriptions: 0,
                        specificNames: 0,
                        qlooIds: 0,
                        realSource: 0,
                        mockSource: 0,
                        highMatches: 0,
                        uniqueNames: new Set()
                    };

                    allResults.forEach(({ query, data }) => {
                        if (data.recommendations) {
                            Object.values(data.recommendations).forEach(items => {
                                if (Array.isArray(items)) {
                                    items.forEach(item => {
                                        // Count patterns
                                        if (item.description && item.description.includes('Great ')) {
                                            patterns.genericDescriptions++;
                                        }
                                        if (item.name && !item.name.includes('Mock')) {
                                            patterns.specificNames++;
                                            patterns.uniqueNames.add(item.name);
                                        }
                                        if (item.id && item.id.includes('qloo_')) {
                                            patterns.qlooIds++;
                                        }
                                        if (item.source === 'qloo') {
                                            patterns.realSource++;
                                        } else if (item.source === 'mock') {
                                            patterns.mockSource++;
                                        }
                                        if (item.match >= 90) {
                                            patterns.highMatches++;
                                        }
                                    });
                                }
                            });
                        }
                    });

                    resultHTML += '<div class="indicator ' + (patterns.realSource > patterns.mockSource ? 'real-indicator' : 'mock-indicator') + '">';
                    resultHTML += '<strong>Pattern Analysis Results:</strong><br>';
                    resultHTML += `‚Ä¢ Generic descriptions: ${patterns.genericDescriptions}<br>`;
                    resultHTML += `‚Ä¢ Specific names: ${patterns.specificNames}<br>`;
                    resultHTML += `‚Ä¢ Unique names: ${patterns.uniqueNames.size}<br>`;
                    resultHTML += `‚Ä¢ Qloo ID format: ${patterns.qlooIds}<br>`;
                    resultHTML += `‚Ä¢ Real source tags: ${patterns.realSource}<br>`;
                    resultHTML += `‚Ä¢ Mock source tags: ${patterns.mockSource}<br>`;
                    resultHTML += `‚Ä¢ High match scores (90%+): ${patterns.highMatches}<br>`;
                    resultHTML += '</div>';

                    // Show some unique names as examples
                    if (patterns.uniqueNames.size > 0) {
                        resultHTML += '<h4>Sample Unique Names (indicates real data):</h4>';
                        resultHTML += '<ul>';
                        Array.from(patterns.uniqueNames).slice(0, 10).forEach(name => {
                            resultHTML += `<li>${name}</li>`;
                        });
                        resultHTML += '</ul>';
                    }

                    // Verdict
                    resultHTML += '<h4>üéØ Verdict:</h4>';
                    if (patterns.realSource > patterns.mockSource && patterns.uniqueNames.size > 10) {
                        resultHTML += '<div class="real-indicator"><strong>‚úÖ LIKELY REAL QLOO DATA</strong><br>';
                        resultHTML += 'Evidence: Diverse unique names, real source tags, Qloo ID format</div>';
                    } else {
                        resultHTML += '<div class="mock-indicator"><strong>‚ùå LIKELY MOCK DATA</strong><br>';
                        resultHTML += 'Evidence: Generic patterns, limited diversity, mock indicators</div>';
                    }
                }

                resultDiv.className = 'success';
                resultDiv.innerHTML = resultHTML;

            } catch (error) {
                resultDiv.className = 'error';
                resultDiv.innerHTML = `<h3>‚ùå Analysis Failed</h3><p>${error.message}</p>`;
            }
        }

        async function testQuery(query) {
            const resultDiv = document.getElementById('query-result');
            resultDiv.className = 'loading';
            resultDiv.innerHTML = `<p>üîÑ Testing query: ${query}...</p>`;

            try {
                // Create appropriate parsed taste structure
                const parsedTaste = {};
                if (query === 'jazz') {
                    parsedTaste.music = { genres: [query], artists: [] };
                } else if (query === 'pizza') {
                    parsedTaste.food = { cuisines: [query], dishes: [] };
                } else if (query === 'tokyo') {
                    parsedTaste.travel = { destinations: [query], activities: [] };
                } else if (query === 'science fiction') {
                    parsedTaste.books = { genres: [query], authors: [] };
                }

                const response = await fetch('/.netlify/functions/get-recommendations-fixed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ parsedTaste })
                });

                const data = await response.json();

                let resultHTML = `<h3>Results for: ${query}</h3>`;
                
                if (data.metadata) {
                    const isReal = data.metadata.usedMockData && Object.values(data.metadata.usedMockData).some(isMock => !isMock);
                    resultHTML += '<div class="indicator ' + (isReal ? 'real-indicator' : 'mock-indicator') + '">';
                    resultHTML += isReal ? '<span class="real-data">REAL DATA</span>' : '<span class="mock-data">MOCK DATA</span>';
                    resultHTML += '</div>';
                }

                if (data.recommendations) {
                    Object.entries(data.recommendations).forEach(([category, items]) => {
                        if (items && items.length > 0) {
                            resultHTML += `<h4>${category} (${items.length} items):</h4>`;
                            items.slice(0, 3).forEach(item => {
                                resultHTML += `<div style="background: #f8f9fa; padding: 8px; margin: 4px 0; border-radius: 4px;">`;
                                resultHTML += `<strong>${item.name}</strong> (${item.match}% match)<br>`;
                                resultHTML += `<small>${item.description}</small>`;
                                resultHTML += `</div>`;
                            });
                        }
                    });
                }

                resultDiv.className = 'success';
                resultDiv.innerHTML = resultHTML;

            } catch (error) {
                resultDiv.className = 'error';
                resultDiv.innerHTML = `<h3>‚ùå Query Test Failed</h3><p>${error.message}</p>`;
            }
        }

        // Auto-run analysis on page load
        window.onload = function() {
            setTimeout(() => {
                testRealVsMock();
            }, 1000);
        };
    </script>
</body>
</html>